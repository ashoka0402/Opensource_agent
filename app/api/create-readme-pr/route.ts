import { NextRequest, NextResponse } from "next/server";
import { Buffer } from "node:buffer";

interface CreatePrRequest {
  repo: string; // owner/repo or URL
  markdown: string;
  branchName?: string;
  commitMessage?: string;
  prTitle?: string;
  prBody?: string;
  token: string; // GitHub PAT or OAuth token
}

function parseRepo(input: string): { owner: string; repo: string } | null {
  try {
    const trimmed = input.trim();
    // Accept owner/repo
    const m = trimmed.match(/^([A-Za-z0-9_.-]+)\/+([A-Za-z0-9_.-]+)$/);
    if (m) return { owner: m[1], repo: m[2] };
    // Accept GitHub URL
    const url = new URL(trimmed);
    if (url.hostname.toLowerCase().includes("github.com")) {
      const parts = url.pathname.replace(/^\//, "").split("/");
      if (parts.length >= 2) return { owner: parts[0], repo: parts[1].replace(/\.git$/, "") };
    }
  } catch {}
  return null;
}

async function gh<T>(path: string, token: string, init?: RequestInit): Promise<T> {
  const res = await fetch(`https://api.github.com${path}`, {
    ...init,
    headers: {
      Accept: "application/vnd.github+json",
      Authorization: `Bearer ${token}`,
      "X-GitHub-Api-Version": "2022-11-28",
      ...(init?.headers || {}),
    },
    // 15s timeout via AbortController if desired (omitted for brevity)
  });
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`GitHub ${res.status} on ${path}: ${text}`);
  }
  return (await res.json()) as T;
}

export async function POST(req: NextRequest) {
  let body: unknown;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  const { repo: repoInput, markdown, branchName, commitMessage, prTitle, prBody, token } = body as CreatePrRequest;
  if (!repoInput || !markdown || !token) {
    return NextResponse.json({ error: "repo, markdown and token are required" }, { status: 400 });
  }
  const parsed = parseRepo(repoInput);
  if (!parsed) return NextResponse.json({ error: "Invalid repo. Use owner/repo or GitHub URL" }, { status: 400 });
  const { owner, repo } = parsed;

  try {
    // 1) Repo info to get default branch
    const repoInfo = await gh<{ default_branch: string }>(`/repos/${owner}/${repo}`, token);
    const baseBranch = repoInfo.default_branch;

    // 2) Get base branch SHA
    const refInfo = await gh<{ object: { sha: string } }>(`/repos/${owner}/${repo}/git/ref/heads/${baseBranch}`, token);
    const baseSha = refInfo.object.sha;

    // 3) Create new branch
    const branch = branchName || `wtb/readme-${Date.now()}`;
    await gh(`/repos/${owner}/${repo}/git/refs`, token, {
      method: "POST",
      body: JSON.stringify({ ref: `refs/heads/${branch}`, sha: baseSha }),
    });

    // 4) Check if README exists on new branch
    let existingSha: string | undefined;
    try {
      const content = await gh<{ sha: string }>(`/repos/${owner}/${repo}/contents/README.md?ref=${encodeURIComponent(branch)}`, token);
      existingSha = content.sha;
    } catch {
      // 404 means not found -> create new file
      existingSha = undefined;
    }

    // 5) Put README.md
    const message = commitMessage || "chore(readme): update README via WhatToBuild";
    const b64 = Buffer.from(markdown, "utf-8").toString("base64");
    await gh(`/repos/${owner}/${repo}/contents/README.md`, token, {
      method: "PUT",
      body: JSON.stringify({
        message,
        content: b64,
        branch,
        sha: existingSha,
      }),
    });

    // 6) Create PR
    const title = prTitle || "Update README via WhatToBuild";
    const bodyText = prBody || "This PR updates the README generated by WhatToBuild.";
    const pr = await gh<{ html_url: string; number: number }>(`/repos/${owner}/${repo}/pulls`, token, {
      method: "POST",
      body: JSON.stringify({
        title,
        head: branch,
        base: baseBranch,
        body: bodyText,
      }),
    });

    return NextResponse.json({ url: pr.html_url, number: pr.number, branch, base: baseBranch });
  } catch (e: unknown) {
    const message = e instanceof Error ? e.message : "Failed to create PR";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
